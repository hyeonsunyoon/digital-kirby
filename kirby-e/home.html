<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>yoon's home</title>
	<style>
		@import url('https://fastly.jsdelivr.net/gh/wanteddev/wanted-sans@v1.0.1/packages/wanted-sans/fonts/webfonts/variable/split/WantedSansVariable.min.css');
		@font-face {
		    font-family: 'intelone-mono-font-family-regular';
		    src: url('https://fastly.jsdelivr.net/gh/projectnoonnu/noonfonts_2307-1@1.1/intelone-mono-font-family-regular.woff2') format('woff2');
		    font-weight: 400;
		    font-style: normal;
		}

		html, body {
			height: 100%;
			font-family: "Wanted Sans", sans-serif;
		}

		body {
			padding: 20px;
		}

		* {
			box-sizing: border-box;
			margin: 0;
			padding: 0;
		}

		.row {
			padding: 5px;

			display: flex;
			flex-direction: row;
			flex-wrap: wrap;
		}

		.column {
			padding: 5px;

			display: flex;
			flex-direction: column;
			flex-wrap: wrap;
		}

		.container {
			padding: 5px;

			flex-wrap: wrap; 
			align-items: flex-start;
		}

		/* profile section style */
		.left-side {
			margin: 5px;

			flex-grow: 1;
			flex-shrink: 1;
			min-width: 300px;
		} 

		/* code section style */
		.right-side {
			margin: 5px;
			padding: 20px;
			border-radius: 8px;

			flex-basis: 600px;
			flex-grow: 3;
			flex-shrink: 1;
			font-family: 'intelone-mono-font-family-regular', monospace;
			min-width: 300px;
			min-height: 500px;

			background-color: black;
			color: white;
		}

		.profile {
			align-items: flex-end;
		}

		/* profile image style */
		.profile img {
			border: 1px solid black;
			width: 66px;
			height: 66px;
			border-radius: 50%;
			object-fit: cover
		}

		#home {
			padding: 5px;
			text-align: center;
		}
		#home a {
			text-decoration: none;
		}
		#name {
			margin-left: 10px;
		}
		hr {
			margin-top: 10px;
			margin-bottom: 10px;
			border: 0.25px solid black;
			height: 0px;
		}

		
	</style>


</head>
<body>
	<div class="row container">

	<!-- profile section start -->
		<div class="column left-side">





			<div class="row profile">
				<!-- 👤 Change your profile image here -->
				<img src="profile-image.jpeg">

				<!-- 🔖 Change your profile name here -->
				<h1 id="name">yoon</h1>
			</div>

			<hr>

			<div class="column bio">
				<!-- 💬 Change your bio here -->
				<p>Welcome to Digi-Kir!</p> 
				<a href="https://ehdbs.neocities.org/clock">What time is it now?</a>
				<a href="https://ehdbs.neocities.org/egg">egg</a>
				<a href="https://ehdbs.neocities.org/">index</a>
			</div>





		</div>


		<!-- code section start -->
		<div class="row right-side">





			<!-- 💻 Edit code here -->
			<code>
				<details>
					<summary>5/9 대화 상자 만들기</summary>
					<p>-flexbox</p><br>

					<p>justify-content : 가로축 기준 관리<br>align-items : 세로축 기준 관리</p><br>

	    			<p>-js로 클릭하면 바뀌는 대화 상자 만들기<br>(전체 코드는 <a href="https://ehdbs.neocities.org/example">해당 웹페이지</a> 참조</p><br>

	    			<p>1. 변수 정의하기 : const는 한 번 할당한 후 다시 할당할 수 없고, let은 값 변경이 가능하다.</p><br>

	    			<p>2. const dialogues를 통해 텍스트를 저장<br>let current = 0; //현재 몇 번째 대사인지<br>let charIndex = 0; //한 문장 내에서 글자가 몇 개 출력되었는지<br>let isTyping = false; //타이핑 애니메이션이 진행 중인지(아직 진행 중 아님)</p><br>

	    			<p>3. function typeDialogue(text) 분석<br>-이 함수는 자동으로 문장의 다음 글자가 타이핑되도록 하는 함수이다.<br><br>-isTyping = true; //타이핑 애니메이션을 진행시킨다<br>box.textContent = ""; //이전 텍스트의 자리를 공백으로 대체시킨다. 즉, 문장을 초기화시킨다.<br>charIndex = 0; //문장은 0에서 시작한다.<br><br>*setInterval : 특정 작업을 일정 시간간격(ms)으로 반복 실행하는 함수이다. clearInterval로 중단시킬 수 있다. 반복을 멈추려면 ID가 필요한데, const로 interval이라는 변수를 정의하는 것으로 ID를 저장한다. 여기서는 '한 글자씩 더하기'가 반복 실행되도록 한다. 아래는 예시이다. <br>0초일 때 : textContent = "" (실행값 :)<br>40ms일 때 : textContent += "안" (실행값 : 안)<br>80ms일 때, : textContent += "녕" (실행값 : 안녕)<br><br>-이 함수가 어떤 문장을 출력할지를 전달받기 위해서 typeDialogue()의 괄호에는 text를 쓴다. (이후 다른 함수에서 text 자리에 dialogues[current]를 써서, 현재 문장을 불러온다.)<br><br>-box.textContent += text[charIndex]; //box에 한 글자씩을 더한다. 대괄호 안에 숫자를 넣으면 해당 인덱스의 값을 불러온다. (여기서는 text의 배열에서 몇 번째에 있는 것을 불러올 것인지 나타낸다.)<br> 따라서 이 부분은, box 안에 쓰인 텍스트 뒤에 가장 마지막 값을 더한다. (위의 예시 참조)<br><br>-charIndex++; //charIndex의 숫자를 하나씩 늘려준다(다음 글자를 불러낼 수 있도록)<br><br>-if (charIndex >= text.length) {clearInterval(interval); isTyping = false;} //만일 charIndex(출력한 글자 수)가 text.length(전체 글자 수)와 같거나 그보다 크다면, 타이핑을 멈춘다.(false)
	    			</p><br><br>

	    			<p>4. function nextDialogue() 분석<br>-이 함수는 클릭 시 다음 문장이 나오도록 하는 함수이다.<br><br>-if (isTyping) return; //return은 함수를 즉시 종료시키는 역할을 한다. 따라서 이 부분은, 만일 isTyping이 true라면(타이핑 중이라면) 함수를 빠져나와 아무 일도 하지 않도록 한다. 즉 글자가 타이핑되는 동안에는 클릭해도 다음 문장이 나오지 않도록 함수를 종료시키는 것이다.<br><br>-if (current < dialogues.length) //만일 현재 문장 개수가 dialogues 개수보다 작으면(즉 아직 출력할 문장이 남았으면)<br>-typeDialogue(dialogues[current]); //typeDialogue(text)의 text 자리에 [current]번째 문장을 넣는다.<br>-current++; //이후 curruent의 숫자를 하나 늘린다(다음 문장을 불러낼 수 있도록)<br><br>-else //만일 현재 문장 개수가 dialogues 개수보다 같거나 크면, 즉 이제 출력할 문장이 없으면<br>-box.textContent = "[대화 끝]"; //박스 안의 문구를 '[대화 끝]'으로 바꾼다.
	    			</p><br><br>

	    			<p>아래 이벤트 리스너는 클릭하면 다음 문장으로 넘어가도록 한다.</p>
	    		</details>
	    		<details>
	    			<summary>5/15 이름 추가하기</summary>
	    			<br>
	    			<p><strong>이름 추가하기</strong></p><br>
	    			<p>-대사 배열을 문자열에서 객체로 변경하기 : name과 text의 조합으로 변경한다. 이후 관리 및 수정이 용이하다.<br>{ name: "나레이터", text: "안녕, 이곳에 온 걸 환영해." }</p><br><br>
	    			<p>-name과 text를 구분해서 각각 변수로 저장한다.<br>const nameBox = document.getElementById("name-box");<br>const textBox = document.getElementById("text-box");</p><br><br>
	    			<p>-typeDialogue 함수가 dialogue 객체를 받도록 설정하고, dialogue.name과 dialogue.text를 따로 출력하게 한다.<br>nameBox.textContent = dialogue.name;<br>textBox.textContent = "";</p><br><br>
	    			<p>-textContent 속성은 HTML 요소의 텍스트 콘텐츠를 가져오거나 설정한다. DOM 요소(Document Object Model)의 텍스트를 읽거나 바꿀 수 있는 내장 프로퍼티이다.</p><br><br>
	    			<p>*의문점 : 이런 식으로 코드를 짜면 사실 그냥 게임 엔진으로 작업하는 것과 다를 게 없지 않을까? 얼마 전 재밌게 플레이했던 웹 게임 <a href="https://adarkroom.doublespeakgames.com/">The Dark Room</a>이 흥미로웠던 기억이 난다. 웹이기에 더 흥미로운 게임을 만들려면 어떻게 해야 할까?</p>
	    		</details>
	    		<details>
	    			<summary>5/23 선택지 만들기</summary><br>
	    			<p><strong>1. 전역 변수를 지역 변수로 바꾸기</strong></p><br>
	    			<p>이전의 charIndex라는 변수를 삭제하고, i = 0으로 새로 정의했다.<br><strong>charIndex</strong>는 전역 변수로 "현재 몇 번째 글자인지"를 나타내는 변수로 사용되었다. <strong>i</strong>는 typeDialogue 함수 안에서만 쓰이는 지역변수이다. charIndex는 함수 바깥에서 선언되어서(전역 변수) 다른 함수와 공유될 수 있고, 다른 대사와 섞일 가능성이 있었다. 따라서 함수 내에서만 쓰이는 지역변수 i를 설정하여, 함수가 실행될 때마다 0부터 시작되도록 0으로 정의했다. (코드를 함수 중심으로 관리하고 싶을 때 자주 쓰이는 방식이라고 함 / i는 'index'의 약자이다.)</p><br><br>
	    			<p><strong>2. 선택지를 고려한 방향으로 코드 수정</strong></p><br>
	    			<p><strong>2-1. 아직 분기를 고르지 않은 상태에서 메인 대사를 출력 중인 경우</strong><br>if (!currentBranch && current < dialogues.length) {<br>typeDialogue(dialogues[current]);<br>current++;<br>
	    			<p>!는 부정을 뜻한다. 즉, !currentBranch 이란 currentBranch가 없다면(비어 있다면)이라는 뜻과 유사<br>
	    			그런데 currentBranch는 null상태(없는 상태)로 시작하므로 !currentBranch는 true가 된다.<br>즉 if (!currentBranch && current < dialogues.length)는<br><br>1. !currentBranch이고(currentBranch가 비어 있고)<br>2. 대사 인덱스가 전체 길이보다 작다면<br>-current번째 dialogues를 출력하라.<br>-current에 하나를 더하라.</p><br>
	    			<p><strong>2-2. 만약 메인 대사의 마지막 대사까지 출력한 직후라면</strong><br>
	    			if (current === dialogues.length) {<br>setTimeout(showChoices, 1000);<br>}<br><br>현재 문장(current)이 마지막이라면, 즉 현재 인덱스 번호와 dialogues의 개수가 같다면, 마지막 대사를 방금 출력했다는 뜻. 이때 1초 후 showChoices 함수를 실행하도록 한다.(여유를 주기 위해서)<br>*여기서 1000은 1000ms 즉 1초를 말한다.</p><br>
	    			<p><strong>3. 분기된 대사 흐름이 있는 경우</strong><br>
	    			else if (currentBranch && current < currentBranch.length) {<br>typeDialogue(currentBranch[current]);<br>current++;<br>
	    			<br>
	    			논리 AND 연산자(&&)는 왼쪽 조건이 거짓이면 오른쪽 조건은 아예 판별하지 않는다. 따라서 currentBranch는 원래 null인 상태로 시작하고, null은 거짓인 값이기 때문에 처음에 이 부분은 실행되지 않는다. currentBranch는 이후 아래에 이어질 함수에서 null->배열 상태로 바뀐다. 이 경우에 currentBranch는 참으로 작동하고, 이후 계산이 진행된다. (아직 남은 문장이 있다면 current번째 문장을 출력 후 인덱스 숫자 추가(다음 대사 위해서)</p><br><br>
	    			<p><strong>4. js에서 버튼을 생성하고 선택지에 따라 분기되도록 하기</strong><br>
	    				function showChoices() {<br>choicesBox.innerHTML = "";<br>const button1 = document.createElement("button");<br>button1.textContent = "알았어.";<br>button1.onclick = () => {<br>currentBranch = branch_알았어;<br>current = 0;<br>choicesBox.innerHTML = "";<br>nextDialogue();<br>};<br><br>const button2 = document.createElement("button");<br>button2.textContent = "누가?";<br>button2.onclick = () => {<br>currentBranch = branch_누가;<br>current = 0;<br>choicesBox.innerHTML = "";<br>nextDialogue();<br>};<br><br>choicesBox.appendChild(button1);<br>choicesBox.appendChild(button2);}<br><br>
	    				위의 함수에서, button1과 2라는 변수를 생성하며 "button"이라는 html 태그를 createElement를 통해 생성한다. 그리고 그 안에 textContent를 통해 텍스트를 작성한다. 클릭하게 되면 currentBranch는 null에서 branch_알았어 혹은 branch_누가가 되고, current는 0이 된다.(branch 안에서 처음부터 시작하도록 초기화)<br>innerHTML은 HTML 요소 안의 내용을 읽거나 바꾸거나 지우는 자바스크립트 속성으로, 비워두는 것으로 버튼 요소를 지운다. 마지막으로 nextDialogue()를 실행한다. 이 경우 else if에서 currentBranch는 참이 되므로 이후 조건이 실행된다.<br>appendChild() 메서드는 새로운 노드를 특정 부모 노드의 자식 노드 리스트 중 마지막 자식으로 붙이는 역할<a href="https://goodafteryoon.tistory.com/165">이라고 한다.</a> 즉 버튼이 choicesBox 그러니까 choice div의 자식 노드가 되어서 나타나게 된다.</p>
	    		</details>
			</code>





		</div>
		
	</div>
	<p id="home"><a href="../index.html">Digital Kirby 2.0</a></p>
	
</body>
</html>