<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<title>yoon's home</title>
	<style>
		@import url('https://fastly.jsdelivr.net/gh/wanteddev/wanted-sans@v1.0.1/packages/wanted-sans/fonts/webfonts/variable/split/WantedSansVariable.min.css');
		@font-face {
		    font-family: 'intelone-mono-font-family-regular';
		    src: url('https://fastly.jsdelivr.net/gh/projectnoonnu/noonfonts_2307-1@1.1/intelone-mono-font-family-regular.woff2') format('woff2');
		    font-weight: 400;
		    font-style: normal;
		}

		html, body {
			height: 100%;
			font-family: "Wanted Sans", sans-serif;
		}

		body {
			padding: 20px;
		}

		* {
			box-sizing: border-box;
			margin: 0;
			padding: 0;
		}

		.row {
			padding: 5px;

			display: flex;
			flex-direction: row;
			flex-wrap: wrap;
		}

		.column {
			padding: 5px;

			display: flex;
			flex-direction: column;
			flex-wrap: wrap;
		}

		.container {
			padding: 5px;

			flex-wrap: wrap; 
			align-items: flex-start;
		}

		/* profile section style */
		.left-side {
			margin: 5px;

			flex-grow: 1;
			flex-shrink: 1;
			min-width: 300px;
		} 

		/* code section style */
		.right-side {
			margin: 5px;
			padding: 20px;
			border-radius: 8px;

			flex-basis: 600px;
			flex-grow: 3;
			flex-shrink: 1;
			font-family: 'intelone-mono-font-family-regular', monospace;
			min-width: 300px;
			min-height: 500px;

			background-color: black;
			color: white;
		}

		.profile {
			align-items: flex-end;
		}

		/* profile image style */
		.profile img {
			border: 1px solid black;
			width: 66px;
			height: 66px;
			border-radius: 50%;
			object-fit: cover
		}

		#home {
			padding: 5px;
			text-align: center;
		}
		#home a {
			text-decoration: none;
		}
		#name {
			margin-left: 10px;
		}
		hr {
			margin-top: 10px;
			margin-bottom: 10px;
			border: 0.25px solid black;
			height: 0px;
		}

		
	</style>


</head>
<body>
	<div class="row container">

	<!-- profile section start -->
		<div class="column left-side">





			<div class="row profile">
				<!-- 👤 Change your profile image here -->
				<img src="profile-image.jpeg">

				<!-- 🔖 Change your profile name here -->
				<h1 id="name">yoon</h1>
			</div>

			<hr>

			<div class="column bio">
				<!-- 💬 Change your bio here -->
				<p>Welcome to Digi-Kir!</p> 
				<a href="https://ehdbs.neocities.org/clock">What time is it now?</a>
				<a href="https://ehdbs.neocities.org/egg">egg</a>
				<a href="https://ehdbs.neocities.org/">index</a>
			</div>





		</div>


		<!-- code section start -->
		<div class="row right-side">





			<!-- 💻 Edit code here -->
			<code>
				<p>-flexbox</p><br>

				<p>justify-content : 가로축 기준 관리<br>align-items : 세로축 기준 관리</p><br>

    			<p>-js로 클릭하면 바뀌는 대화 상자 만들기<br>(전체 코드는 <a href="https://ehdbs.neocities.org/example">해당 웹페이지</a> 참조</p><br>

    			<p>1. 변수 정의하기 : const는 한 번 할당한 후 다시 할당할 수 없고, let은 값 변경이 가능하다.</p><br>

    			<p>2. const dialogues를 통해 텍스트를 저장<br>let current = 0; //현재 몇 번째 대사인지<br>let charIndex = 0; //한 문장 내에서 글자가 몇 개 출력되었는지<br>let isTyping = false; //타이핑 애니메이션이 진행 중인지(아직 진행 중 아님)</p><br>

    			<p>3. function typeDialogue(text) 분석<br>-이 함수는 자동으로 문장의 다음 글자가 타이핑되도록 하는 함수이다.<br><br>-isTyping = true; //타이핑 애니메이션을 진행시킨다<br>box.textContent = ""; //이전 텍스트의 자리를 공백으로 대체시킨다. 즉, 문장을 초기화시킨다.<br>charIndex = 0; //문장은 0에서 시작한다.<br><br>*setInterval : 특정 작업을 일정 시간간격(ms)으로 반복 실행하는 함수이다. clearInterval로 중단시킬 수 있다. 반복을 멈추려면 ID가 필요한데, const로 interval이라는 변수를 정의하는 것으로 ID를 저장한다. 여기서는 '한 글자씩 더하기'가 반복 실행되도록 한다. 아래는 예시이다. <br>0초일 때 : textContent = "" (실행값 :)<br>40ms일 때 : textContent += "안" (실행값 : 안)<br>80ms일 때, : textContent += "녕" (실행값 : 안녕)<br><br>-이 함수가 어떤 문장을 출력할지를 전달받기 위해서 typeDialogue()의 괄호에는 text를 쓴다. (이후 다른 함수에서 text 자리에 dialogues[current]를 써서, 현재 문장을 불러온다.)<br><br>-box.textContent += text[charIndex]; //box에 한 글자씩을 더한다. 대괄호 안에 숫자를 넣으면 해당 인덱스의 값을 불러온다. (여기서는 text의 배열에서 몇 번째에 있는 것을 불러올 것인지 나타낸다.)<br> 따라서 이 부분은, box 안에 쓰인 텍스트 뒤에 가장 마지막 값을 더한다. (위의 예시 참조)<br><br>-charIndex++; //charIndex의 숫자를 하나씩 늘려준다(다음 글자를 불러낼 수 있도록)<br><br>-if (charIndex >= text.length) {clearInterval(interval); isTyping = false;} //만일 charIndex(출력한 글자 수)가 text.length(전체 글자 수)와 같거나 그보다 크다면, 타이핑을 멈춘다.(false)
    			</p><br><br>

    			<p>4. function nextDialogue() 분석<br>-이 함수는 클릭 시 다음 문장이 나오도록 하는 함수이다.<br><br>-if (isTyping) return; //return은 함수를 즉시 종료시키는 역할을 한다. 따라서 이 부분은, 만일 isTyping이 true라면(타이핑 중이라면) 함수를 빠져나와 아무 일도 하지 않도록 한다. 즉 글자가 타이핑되는 동안에는 클릭해도 다음 문장이 나오지 않도록 함수를 종료시키는 것이다.<br><br>-if (current < dialogues.length) //만일 현재 문장 개수가 dialogues 개수보다 작으면(즉 아직 출력할 문장이 남았으면)<br>-typeDialogue(dialogues[current]); //typeDialogue(text)의 text 자리에 [current]번째 문장을 넣는다.<br>-current++; //이후 curruent의 숫자를 하나 늘린다(다음 문장을 불러낼 수 있도록)<br><br>-else //만일 현재 문장 개수가 dialogues 개수보다 같거나 크면, 즉 이제 출력할 문장이 없으면<br>-box.textContent = "[대화 끝]"; //박스 안의 문구를 '[대화 끝]'으로 바꾼다.
    			</p><br><br>

    			<p>아래 이벤트 리스너는 클릭하면 다음 문장으로 넘어가도록 한다.</p>


			</code>





		</div>
		
	</div>
	<p id="home"><a href="../index.html">Digital Kirby 2.0</a></p>
	
</body>
</html>